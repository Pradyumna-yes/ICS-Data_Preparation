import os
import re
import uuid
import pandas as pd
from datetime import datetime
from flask import Flask, render_template, request, redirect, url_for, send_from_directory, flash

app = Flask(__name__)
app.config.update({
    'UPLOAD_FOLDER': 'uploads',
    'ALLOWED_EXTENSIONS': {'xlsx', 'csv'},
    'SECRET_KEY': os.environ.get('FLASK_SECRET', 'supersecretkey'),
    'MAX_CONTENT_LENGTH': 16 * 1024 * 1024  # 16MB
})

os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']

class DataValidator:
    def __init__(self):
        self.errors = []
        
    def validate(self, df):
        self.errors = []
        self._clean_data(df)
        self.validate_iban(df)
        self.validate_vat(df)
        self.validate_amounts(df)
        self.validate_dates(df)
        self.validate_bic(df)
        return self.errors
    
    def _clean_data(self, df):
        df.columns = df.columns.str.strip().str.upper()
        df.replace({'\$': '', ',': ''}, regex=True, inplace=True)
        
    def validate_iban(self, df):
        for idx, row in df.iterrows():
            iban = str(row.get('IBAN', '')).replace(' ', '').upper()
            if not re.match(r'^[A-Z]{2}\d{2}[A-Z0-9]{1,30}$', iban):
                self.errors.append({
                    'type': 'Validation',
                    'row': idx + 2,
                    'field': 'IBAN',
                    'current_value': row.get('IBAN', ''),
                    'tip': ('IBAN Requirements:<br>'
                            '- Starts with 2-letter country code<br>'
                            '- Followed by 2 check digits<br>'
                            '- 15-30 alphanumeric characters<br>'
                            '- No special characters allowed<br>'
                            'Example: GB29NWBK60161331926819')
                })
    
    def validate_vat(self, df):
        vat_pattern = r'^[A-Z]{2,4}[0-9A-Z]{5,20}$'
        for idx, row in df.iterrows():
            vat = str(row.get('VAT', '')).replace(' ', '').upper()
            if not re.match(vat_pattern, vat):
                self.errors.append({
                    'type': 'Validation',
                    'row': idx + 2,
                    'field': 'VAT',
                    'current_value': row.get('VAT', ''),
                    'tip': ('VAT Requirements:<br>'
                            '- 8-12 alphanumeric characters<br>'
                            '- Country-specific format<br>'
                            '- No spaces or special characters')
                })
    
    def validate_amounts(self, df):
        for idx, row in df.iterrows():
            amount = str(row.get('AMOUNT', '')).strip()
            if not re.match(r'^-?\d+(?:\.\d{1,2})?$', amount):
                self.errors.append({
                    'type': 'Validation',
                    'row': idx + 2,
                    'field': 'AMOUNT',
                    'current_value': row.get('AMOUNT', ''),
                    'tip': ('Amount Requirements:<br>'
                            '- Numeric value only<br>'
                            '- Optional decimal point<br>'
                            '- Maximum 2 decimal places<br>'
                            'Example: 1234.56')
                })
    
    def validate_dates(self, df):
        for idx, row in df.iterrows():
            date_str = str(row.get('TRANSACTION_DATE', ''))
            try:
                datetime.strptime(date_str, '%Y-%m-%d')
            except ValueError:
                self.errors.append({
                    'type': 'Validation',
                    'row': idx + 2,
                    'field': 'TRANSACTION_DATE',
                    'current_value': date_str,
                    'tip': ('Date Requirements:<br>'
                            '- Format: YYYY-MM-DD<br>'
                            '- Valid calendar date<br>'
                            '- Between 2000 and current year<br>'
                            'Example: 2023-09-15')
                })
    
    def validate_bic(self, df):
        bic_pattern = r'^[A-Z]{6}[A-Z0-9]{2}([A-Z0-9]{3})?$'
        for idx, row in df.iterrows():
            bic = str(row.get('BIC', '')).replace(' ', '').upper()
            if bic and not re.match(bic_pattern, bic):
                self.errors.append({
                    'type': 'Validation',
                    'row': idx + 2,
                    'field': 'BIC',
                    'current_value': row.get('BIC', ''),
                    'tip': ('BIC/SWIFT Requirements:<br>'
                            '- 8 or 11 characters<br>'
                            '- Letters and digits only<br>'
                            '- Format: AAAABBCC[DDD]<br>'
                            'Example: DEUTDEFF500')
                })

@app.route('/')
def index():
    return render_template('upload.html')

@app.route('/process', methods=['POST'])
def process_file():
    try:
        if 'file' not in request.files:
            flash('No file selected')
            return redirect(url_for('index'))
            
        file = request.files['file']
        password = request.form.get('password', '')
        
        if not file or not allowed_file(file.filename):
            flash('Invalid file type')
            return redirect(url_for('index'))

        file_id = str(uuid.uuid4())
        file_path = os.path.join(app.config['UPLOAD_FOLDER'], f"{file_id}_original{os.path.splitext(file.filename)[1]}")
        file.save(file_path)
        
        try:
            if file.filename.endswith('.xlsx'):
                df = pd.read_excel(file_path, engine='openpyxl')
            else:
                df = pd.read_csv(file_path)
        except Exception as e:
            flash(f'Error reading file: {str(e)}')
            return redirect(url_for('index'))

        validator = DataValidator()
        errors = validator.validate(df)
        
        clean_path = os.path.join(app.config['UPLOAD_FOLDER'], f"{file_id}_clean.xlsx")
        df.to_excel(clean_path, index=False)
        
        output_filename = f"Cleaned_{os.path.splitext(file.filename)[0]}_{datetime.now().strftime('%Y%m%d%H%M')}.csv"
        output_path = os.path.join(app.config['UPLOAD_FOLDER'], output_filename)
        df.to_csv(output_path, index=False)

        return render_template('results.html',
                             filename=file.filename,
                             errors=errors,
                             output_file=output_filename,
                             file_id=file_id)

    except Exception as e:
        flash(f'Processing error: {str(e)}')
        return redirect(url_for('index'))

@app.route('/download/<filename>')
def download_file(filename):
    return send_from_directory(app.config['UPLOAD_FOLDER'], filename, as_attachment=True)

@app.route('/apply-fixes', methods=['POST'])
def apply_fixes():
    try:
        file_id = request.form['file_id']
        clean_path = os.path.join(app.config['UPLOAD_FOLDER'], f"{file_id}_clean.xlsx")
        
        if not os.path.exists(clean_path):
            flash('Session expired. Please re-upload your file.')
            return redirect(url_for('index'))

        df = pd.read_excel(clean_path)
        updates = 0

        for key, value in request.form.items():
            if key.startswith('fix_'):
                _, row_str, field = key.split('_', 2)
                row_idx = int(row_str) - 2  # Convert to 0-based index
                
                if 0 <= row_idx < len(df):
                    df.at[row_idx, field] = value.strip()
                    updates += 1

        corrected_filename = f"Corrected_{datetime.now().strftime('%Y%m%d%H%M%S')}.csv"
        corrected_path = os.path.join(app.config['UPLOAD_FOLDER'], corrected_filename)
        df.to_csv(corrected_path, index=False)
        
        # Cleanup temporary files
        for f in [clean_path]:
            if os.path.exists(f):
                os.remove(f)

        return send_from_directory(
            app.config['UPLOAD_FOLDER'],
            corrected_filename,
            as_attachment=True,
            download_name=corrected_filename
        )

    except Exception as e:
        flash(f'Error applying fixes: {str(e)}')
        return redirect(url_for('index'))

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)
